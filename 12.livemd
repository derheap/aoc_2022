# Day 12: Hill Climbing Algorithm

```elixir
Mix.install([
  {:kino, "~> 0.7.0"}
])

import ExUnit.Assertions
```

## Import data

```elixir
# input_field = Kino.Input.textarea("Please paste your input file:")
input = File.read!(__DIR__ <> "/input/12.txt")
```

## Helper

```elixir
defmodule AOC do
  def split_lines(text), do: String.split(text, "\n", trim: true)
  def split_chunks(text), do: String.split(text, "\n\n", trim: true)
end
```

## Part 1

```elixir
test_input = """
Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
"""
```

<https://adventofcode.com/2022/day/12>

## Parser

```elixir
defmodule Node do
  defstruct height: ?a, cost: 9_999_999, visited: false, edges: []
end

defmodule Parse do
  def run(input) do
    input
    |> AOC.split_lines()
    # Add row index
    |> Enum.with_index()
    |> Enum.map(fn {line, row} ->
      # Add col index
      Enum.with_index(
        String.split(line, "", trim: true),
        # and build {{x,y},el} tuple
        # Fix height for end
        fn el, idx ->
          {{idx + 1, row + 1},
           %Node{
             height:
               case hd(String.to_charlist(el)) do
                 ?E -> ?z + 1
                 x -> x
               end
           }}
        end
      )
    end)
    |> Enum.flat_map(&Function.identity/1)
    |> Map.new()
  end
end

nodes = Parse.run(test_input)
```

```elixir
defmodule One do
  @doc """
  Find node to start
  """
  def start(nodes) do
    s =
      nodes
      |> Map.filter(fn {_, v} -> v.height == ?S end)
      |> Map.keys()

    hd(s)
  end

  def can_step_to(nodes, {x, y}, height) do
    case Map.fetch(nodes, {x, y}) do
      {:ok, dest} ->
        if dest.height <= height + 1, do: {x, y}, else: false

      _ ->
        false
    end
  end

  def can_reach(nodes, {x, y}, height) do
    # Fix height for start
    height = if height == ?S, do: ?a, else: height

    Enum.filter(
      [
        can_step_to(nodes, {x - 1, y}, height),
        can_step_to(nodes, {x + 1, y}, height),
        can_step_to(nodes, {x, y - 1}, height),
        can_step_to(nodes, {x, y + 1}, height)
      ],
      &Function.identity/1
    )
  end

  def run(input) do
    nodes = Parse.run(input)
    first = start(nodes)

    nodes
    |> Map.update(first, node, fn node -> %{node | cost: 0} end)
    |> dijkstra(first, [], MapSet.new())
  end

  def update_cost(nodes, pos, cost) do
    Map.update(nodes, pos, node, fn node ->
      if cost < node.cost, do: %{node | cost: cost}, else: node
    end)
  end

  def print_way(nodes) do
    nodes
    |> Map.to_list()
    |> Enum.sort(&sort_by_cost/2)
    |> Enum.each(fn {p, n} ->
      IO.puts(Enum.join(Tuple.to_list(p), ",") <> " @" <> Integer.to_string(n.cost))
    end)
  end

  def sort_by_cost({_, a}, {_, b}) do
    a.cost < b.cost
  end

  def sort_nodes_by_cost(nodes, a, b) do
    node_a = Map.fetch!(nodes, a)
    node_b = Map.fetch!(nodes, b)
    node_a.cost < node_b.cost
  end

  def dijkstra(nodes, current, visited, seen) do
    # IO.inspect({current, seen}, label: "dijkstra")
    {:ok, node} = Map.fetch(nodes, current)

    if node.height == ?z + 1 do
      IO.inspect(current, label: "DONE")
      IO.inspect(node, label: "DONE")
      #    print_way(nodes)
    else
      nodes =
        Map.update(nodes, current, node, fn node ->
          %{node | visited: true}
        end)

      possible_nodes = can_reach(nodes, current, node.height)
      cost = node.cost + 1
      # IO.inspect(possible_nodes)
      # Update cost for all visible nodes
      nodes =
        possible_nodes
        |> Enum.reduce(nodes, fn pos, nodes -> update_cost(nodes, pos, cost) end)

      # Find notes to visited
      not_visited =
        possible_nodes
        |> Enum.reject(fn pos ->
          {:ok, n} = Map.fetch(nodes, pos)
          n.visited
        end)

      # IO.inspect(MapSet.new(not_visited))
      seen = MapSet.union(seen, MapSet.new(not_visited))
      # IO.inspect(seen)

      # Select node with minimum cost
      if MapSet.size(seen) > 0 do
        seen
        |> MapSet.to_list()
        |> Enum.sort(fn a, b -> sort_nodes_by_cost(nodes, a, b) end)
        |> hd()
        |> then(fn next ->
          dijkstra(nodes, next, [current | visited], MapSet.delete(seen, next))
        end)
      else
        # IO.inspect(Enum.reverse(visited))
        node
      end
    end
  end
end

One.run(test_input)
```

```elixir
One.run(input)
```

## Part 2

```elixir
defmodule Two do
  def run(input) do
  end
end

Two.run(test_input)
```

```elixir
result = Two.run(input)
```

## Both parts

```elixir
IO.puts("--- Part one ---")
assert(One.run(test_input) == 42, "Part 1 with test input failed")
result = One.run(input)
assert(result == 42, "Part 1 failed")
IO.puts(result)

IO.puts("--- Part two ---")
assert(Two.run(test_input) == 23, "Part 2 with test input failed")
result_2 = Two.run(input)
assert(result_2 == 23, "Part 2 failed")
IO.puts(result_2)
```
