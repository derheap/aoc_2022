# Day 23: Unstable Diffusion

```elixir
Mix.install([
  {:kino, "~> 0.7.0"},
  {:vega_lite, "~> 0.1.6"},
  {:kino_vega_lite, "~> 0.1.7"}
])

alias VegaLite, as: Vl

import ExUnit.Assertions
```

## Import data

```elixir
# input_field = Kino.Input.textarea("Please paste your input file:")
input = File.read!(__DIR__ <> "/input/23.txt")
```

## Helper

```elixir
defmodule AOC do
  def split_lines(text), do: String.split(text, "\n", trim: true)
  def split_chunks(text), do: String.split(text, "\n\n", trim: true)
end
```

## Part 1

```elixir
test_input = """
..............
..............
.......#......
.....###.#....
...#...#.#....
....#...##....
...#.###......
...##.#.##....
....#..#......
..............
..............
..............
"""
```

<https://adventofcode.com/2022/day/12>

## Parser

```elixir
defmodule Elv do
  defstruct proposed: nil, new_pos: nil
end

defmodule Parse do
  def run(input) do
    input
    |> AOC.split_lines()
    |> Enum.with_index()
    |> Enum.map(fn {line, y} ->
      String.to_charlist(line)
      |> Enum.with_index(fn element, x -> {{x, y}, element} end)
    end)
    |> Enum.flat_map(& &1)
    |> Enum.filter(fn {pos, element} -> element == ?# end)
    |> Enum.map(fn {pos, _} -> {pos, %Elv{}} end)

    # |> Map.new()
  end
end

Parse.run(test_input)
```

```elixir
defmodule One do
  def run(input) do
    input
    |> Parse.run()
    |> move_elves([], 1)
  end

  def move_elves(elves, moved, round) do
    map = Map.new(elves)

    elves
    |> Enum.map(&propose_move(&1, map, round))
  end

  def directions(round) when rem(round, 4) == 1, do: [:north, :east, :south, :west]
  def directions(round) when rem(round, 4) == 2, do: [:east, :south, :west, :north]
  def directions(round) when rem(round, 4) == 3, do: [:south, :west, :north, :east]
  def directions(round) when rem(round, 4) == 4, do: [:west, :north, :east, :south]

  def free(pos, map), do: !Map.has_key?(map, pos)

  def can_move({x, y}, map, :north) do
    free({x - 1, y - 1}, map) || free({x, y - 1}, map) || free({x + 1, y - 1}, map)
  end

  def can_move({x, y}, map, :south) do
    free({x - 1, y + 1}, map) || free({x, y + 1}, map) || free({x + 1, y + 1}, map)
  end

  def can_move({x, y}, map, :west) do
    free({x - 1, y + 1}, map) || free({x - 1, y}, map) || free({x - 1, y - 1}, map)
  end

  def can_move({x, y}, map, :east) do
    free({x + 1, y + 1}, map) || free({x + 1, y}, map) || free({x + 1, y - 1}, map)
  end

  def propose_move(elve, map, round) do
  end
end

One.run(test_input)
```

```elixir
One.run(input)
```

```elixir
data = test_input

chart =
  Vl.new(width: 800, height: 800)
  |> Vl.layers([
    Vl.new()
    |> Vl.data_from_values(
      Parse.run(data)
      |> Enum.map(fn {{x, y}, _} -> %{"x" => x, "y" => y, "h" => 1} end)
    )
    |> Vl.mark(:rect, opacity: 0.9)
    |> Vl.encode_field(:x, "x", type: :nominal, axis: nil)
    |> Vl.encode_field(:y, "y", type: :nominal, axis: nil)
    |> Vl.encode(:color, field: "h", type: :quantitative),
    Vl.new()
    |> Vl.mark(:text, color: :white, angle: -45)
    |> Vl.encode_field(:x, "x", type: :nominal, axis: nil)
    |> Vl.encode_field(:y, "y", type: :nominal, axis: nil)
    |> Vl.encode(:text, field: "c", type: :quantitative)
  ])
  |> Kino.VegaLite.new()
  |> Kino.render()

for %{id: {x, y}, cost: c} <- One.run(data) do
  Kino.VegaLite.push(chart, %{"x" => x, "y" => y, "h" => -25, "c" => c})
  # Process.sleep(1)
end
```

## Part 2

```elixir
defmodule Two do
  def run(input) do
  end
end

Two.run(test_input)
```

```elixir
result = Two.run(input)
```

## Both parts

```elixir
IO.puts("--- Part one ---")
assert(One.run(test_input) == 42, "Part 1 with test input failed")
result = One.run(input)
assert(result == 42, "Part 1 failed")
IO.puts(result)

IO.puts("--- Part two ---")
assert(Two.run(test_input) == 23, "Part 2 with test input failed")
result_2 = Two.run(input)
assert(result_2 == 23, "Part 2 failed")
IO.puts(result_2)
```
